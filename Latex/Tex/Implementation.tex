\section{Implementation}%
\label{sec:implementation}
% We have implemented a full-featured prototype of HyperPS.


\subsection{HyperPS Space}%
\label{sub:hyperps_space}
% In this paper, HyperPS creates a delicate kernel-level secure and isolated execution space, called HyperPS Space, to inherit privileges of managing physical memory that originally belonged to the compromised hypervisor.
% HyperPS does not rely on a higher privileged layer or any special hardwares.
\iffalse 

实现了虚拟机的隔离主要通过保护和隔离EPT和虚拟机内存来完成，主要完成4部分，1）实现vm-mark表，将VM与EPT进行绑定确保各虚拟机只能访问自己的EPT。2）hyperps剥离了EPT相关的所有访问函数，保证ept表的安全访问。以防被恶意更改。3）页分配时实现page-mark表，来标注page唯一的属主vm，保证vm-ept-page的一致性。在页分配时验证页的属主，空页绑定页与vm，非空页验证属主，以免页被重新分配。4）页释放时清除页内容。如果原vm的内容页在释放时未被清除，当该页再次分配给其余虚拟机时，其上的内容可能被恶意虚拟机读取而泄露数据。

We propose ept isolation and vm isolation by preventing ept access and released vm page access , following the steps. 1) Guarantee the consistency of vm and ept. Making vm-ept mark table to ensure EPT isolation and one VM only access own corresponding EPT. 2) Strips ept access privilege. Strips all access functions related to EPT to ensure safe access and to ept and prevent malicious changes. 3) Page-mark table. The page-mark table is created marking the unique owner vm of the page during page allocation. So the consistency of vm-ept-page can ensure ept isolation and vm isolation, one vm can only access own ept and own pages. During page allocation, the owner of the page is verified, empty pages are bound to the vm directly, and the allocated page is discarded to prevent the page from being remapped. 4)Clear page content when released. If the content page of the original vm is not cleared after being released, after allocated to other virtual machines again, the content on the page may be read by a malicious virtual machine so that privacy data may be leaked.
 
It is important to ensure EPT isolation and one VM only access own corresponding EPT. To ensure one EPT for one VM, HyperPS creates the VM-Mark structure stored in HyperPS World as Table I described. It records VMID, EPTID, EPT Address and binds them together. VMID is created when the VM is created. EPTID and EPT Address is recorded as long as the EPT of current VM is created. This table is destroy once the VM is shutdown or destroyed.
 
Vm-ept mark table is hidden in hyperps world. all access functions for EPT address must be executed in hyperps world. When EPT is created, use the hash function to construct the ID number of the ept according to the ept address, bind it to the current VMID as a structure, the relationship between VM and EPT is established. Other access functions of EPT, such as reading and writing,updating will be executed  in hyperps wolrd for safety.
Stripping EPT's access capability can prevent attackers from tampering with EPT. When 
\fi


In this paper, we create a delicate kernel-level trusted execution environment, called HyperPS Space, to inherit privileges of managing physical memory that originally belonged to the compromised hypervisor. 
The HyperPS Space achieves isolation and secure context switching without relying on a higher privileged layer or any special hardware. 
% As shown in Figure \ref{fig:address}, we create the HyperPS Space by using two set of page tables.
% describes the address layout of HyperPS.

\iffalse
在创建的时候，要讲明白为什么是Hypervisor的情况下，要从hostos出发。
首先是创建，创建完成之后再写如何保证隔离的 即prohibit the kernel from modifying the momory layout or access permission of the system.
\fi
% does not rely on a higher privileged layer or any special hardwares.


\subsubsection{The Creation of HyperPS Space}%
\label{ssub:hyperps_space_creation}

\iffalse
% Figure \ref{fig:address} describes the address layout of HyperPS.
这段要说明为什么要在hostOS上使用两套页表的方法创建同层隔离的空间。
当hostos已经不可信的时候，我们需要一个全新的TEE用于host我们的保护工具。在这篇文章中，我们采用了同层隔离的方式来创建我们的TEE。
我们通过两步创建我们的space，首先是在什么地方创建，其次是保证其隔离性。
% 一个合格的TEE应该
\fi

In our prototype, we create the HyperPS Space by using two sets of page tables.  
Figure \ref{fig:address} describes the address layout of HyperPS. 
\begin{figure}[htpb]
    \centering
    \includegraphics[width=0.8\linewidth]{IMG/address.pdf}
    \caption{Address layout of HyperPS}%
    \label{fig:address}
\end{figure}


% However,
% HyperPS Space的创建并不能在kernel boot阶段，因为此时，内核需要
% hostos的kernel并不能在boot的时候就直接完成两套页表的建立。
% As shown in this figure, HyperPS has to load itself into memory at first.
As shown in this figure, at the initialization stage, HyperPS has to load itself into memory firstly before it got executed. 
At this stage, all resources are managed by the Hostos kernel, HyperPS needs to request enormous numbers of memory allocation from the Hostos. These memories are used to hold HyperPS data and security tools that inherit compromised hypervisor's privileges of managing physical memory. 
In our prototype, we do not guarantee that all allocated memories are continuous in physical memory. 
Secondly, HyperPS creates a new page table that has already excluded the HyperPS Space. As shown in Figure \ref{fig:address}, this dedicated page table is placed in the Normal Space and accessed by the compromised HostOS kernel. 
Because all page table entries that are relative to HyperPS Space have been removed from that dedicated page table, 
% normal memory access beyond the HyperPS Space can not visit memory regions of HyperPS Space.
memory regions used by HyperPS are carved out of the memory ranges accessible to the HostOS kernel. 
% Thirdly, HyperPS will set a new GDT, IDT and stack for itself.
At last, HyperPS returns execution back to the Normal Space by loading the address of the dedicated page table into the control register CR3. 

On the execution of the three steps mentioned above, HyperPS has established an execution environment. 
However, at this time, this execution environment does not have the conditions for isolation and security, since the kernel can still modify this memory layout or access permission. 


\subsubsection{The Isolation of HyperPS Space}%
\label{ssub:the_isolation_of_hyperps_space}
% HyperPS has created a protected virtual address space.
HyperPS has to guarantee that the memory regions used by HyperPS are carved out of the memory ranges accessible to the kernel.
In order to achieve the isolation of the HyperPS Space, HyperPS restricts the compromised HostOS kernel access to this space. 
% To protect HyperPS Space, firstly, we deprive the write permission to whole kernel page tables,
Firstly, we removed write permissions to whole kernel page tables, so that the HostOS kernel can not modify the dedicated kernel page table in the Normal Space. In our prototype, the HostOS kernel can still navigate and examine page table entries, while write operations through legitimate page table management functions and macros are hooked and redirected into HyperPS Space. 
Meanwhile, direct write operations to the dedicated kernel page table will trigger an error (segment fault). 
% In our prototype, all page table write operations are completed inside the HyperPS Space.
% any modification operation will
% to
% navigation and examination of page table entries
% so that they are exclusively writable to HyperPS in the HyperPS Space.
% To protect HyperPS Space, write permission to HostOS kernel page tables
Secondly, as mentioned above, HyperPS removed all page table management functions and macros and replaced them with hooks that jump to HyperPS Space, so that any modification to the dedicated kernel page table in the Normal Space will be redirected to HyperPS Space. 
For example, \verb|native_set_pte()| is the function that actually implements PTE operations. Other PTE operation functions such as \verb|set_pte()| and \verb|native_set_pte_atomic()| all invoke the \verb|native_set_pte()| function to accomplish their implementation. 
% implement their
% will implement their operation by invoking this function.
In our prototype, HyperPS hooks all these final and elemental page table management functions and macros.
% For example, we hooked \verb|native_set_pte|, \verb|native_set_pmd| and \verb|do_page_fault|
HyperPS makes sure that the HostOS kernel can neither tamper the virtual memory permissions of the HyperPS Space, nor can it establish new mapping relationships to the physical memory frames related to the HyperPS Space. 
% For example,
In other word, the HostOS kernel page table is exclusively writable to HyperPS only. 
Lastly, HyperPS deprives the HostOS kernel of executing certain Control-Register-Relative functions so that it cannot direct the CPU to use alternative page tables other than the dedicated one we put in the Normal Space. 
% In this paper, HyperPS instrumented the kernel code to remove certain Control-Register-Relative functions.
For example, \verb|native_write_cr3()| is written with inline assembly language to load the page table's physical address into the register CR3. 
HyperPS instrumented this function to prevent the adversary from using an unverified page table. 
% HyperPS instrumented the function \verb|native_write_cr3| to prevent the adversary from using a unverified page table.
HyperPS also intercept the accessing operation to Control Register: CR0 to prevent the adversary from disabling the WP protection mechanism.
Actually, HyperPS hooked \verb|native_write_cr0()|, \verb|native_write_cr2()|, \verb|native_write_cr3()|, and \verb|native_write_cr4()| to HyperPS Space.
% redirect the execution to HyperPS Space.
% , such as the ones that change the vulue of CR0, CR3, and CR4.
By enforcing these three steps, the HostOS kernel running in the Normal Space can neither modify the dedicated host kernel page table nor change the control register configurations to use unverified page tables. 
As a result, the HostOS kernel cannot violate the isolation provided to HyperPS, since HyperPS deprives the HostOS kernel of privileges of accessing control registers and page tables and retains these privileges in the HyperPS Space.

% As a result, the HostOS kernel cannot violate the isolation provided to HyperPS, while HyperPS retains the exclusive access to control the control registers and page tables in the HyperPS Space.
% which
% is deprived the privileges of accessing to control registers and page tables in the HyperPS Space.
% retains the exclusive access to control the control registers and page tables in the HyperPS Space.



\iffalse
HyperPS makes sure that the HostOS kernel cannot modify any of the dedicated kernel page table to tamper the virtual memory access permissions of HyperPS Space. 

memory region used by HyperPS are carved out of the memory ranges accessible to the kernel.

In another word, the HostOS kernel page table are exclusively writable to HyperPS only. 


HyperPS will check 
so that the HostOS kernel is not allowed to change any ken
% Secondly, we also hook all page table management functions and macros to HyperPS Space, so that

. For example, we instrumented 

all page table functions 

这里HyperPS分为两步实现保护，一方面限制所有PT访问的函数。另外一方面限制CR3函数 

It starts by instrumenting the kernel code to remove certain MMU control instructions. such as the ones that change the location of memory tranlation tables. 
SEKK also monitor memory layout changes to guarantee that no other unverified privileged code is allowed to execute. 

hook的函数：
pte pme pagefualt 
vmcs read write clear 
pfn modify map 
clean page modify 
ksm page modify
\fi


\iffalse
下面的这部分内容应该是保护的内容，涉及的是EPT和缺页中断的处理，不应该是地址空间创建这部分内容。
在QEMU-KVM架构下，一台虚拟机的memory space同时受宿主机的page table和EPT两套页表管理。
% 在non-root模式下，
对于宿主机而言，虚拟机就是一个qemu进程，这个与其他的普通进程没有区别，宿主机通过传统的页表管理qemu所需要的所有地址空间。hostOS负责实际分配给该虚拟机的所有物理页框。
当EPT enable的时候，
在root模式下，EPT负责将qemu进程的

在QEMU-KVM架构下，以HostOS 视角看，整个虚拟机即为一个QEMU进程，EPT用于管理已经分配给QMEU进程中的物理页。
Traditional page tables continue to be reponsible for FVA-GPA, while EPT is responsible for GPA-HPA.
\fi

\iffalse
As shown in the Figure \ref{fig:address}, HyperPS creates the delicate kernel-level secure and isolated execution space by using two sets of page tables. 
On the left side of Figure \ref{fig:address}, the normal page table contains code and data of the HostOS kernel world. However, page table entries about the HyperPS Space has been removed from this table. %The attacker can not subvert the HyperPS Space 
Because all corresponding page table entries have been removed, the attacker can not find out in which memory the HyperPS Space locates, let alone subvert programs in the HyperPS Space. 
As shown in the Figure \ref{fig:address}, The Switch Gate is the only way that can perform the context switch from the Normal Space (the original hypervisor space) to the HyperPS Space.
On the other side of Figure \ref{fig:address}, HyperPS safeguard the integral page tables which contain both the kernel code, data and the HyperPS code, data. Besides, HyperPS removed the execution permission of all kernel code to prevent unauthorized code execution.
\fi

% \subsection{Switch Gate}
\subsection{Secure Switching}%
\label{sub:secure_switching}


Switch Gate is designed to allow secure switching between HyperPS Space and the Normal Space, and it is the only interface between the Normal Space and the HyperPS Space. In this paper, HyperPS adopts a technique similar to the one presented in SKEE \cite{azab2016skee}. Our Switch Gate can achieve atomic, deterministic and exclusive too.
% Switch Gate is the only interface between the Normal Space and the HyperPS Space. HyperPS adopts a technique similar to the one presented in SKEE \ref{Azab2016SKEE}. In this paper, our Switch Gate is designed to allow secure switching between HyperPS Space and the Normal Space. Our Switch Gate is designed to be atomic, deterministic and exclusive too.
As shown in the middle block of Figure \ref{fig:address}, the Switch Gate mainly consists of three parts: the Entry Gate, the Exit Gate and the Shared Buffer. 
The Entry Gate provides the only entrance for HyperPS Space. The Entry Gate will save the HostOS kernel state into the Shared Buffer first. Secondly, it will clear and disable interrupts. Interrupts could enable the compromised HostOS kernel to crash the atomic execution of Switch Gate. 
Then HyperPS will enter the HyperPS Space by loading the page table used by HyperPS Space into register Cr3. 
% load the page table used by HyperPS Space into register CR3.
The address of this page table is visible to HostOS kernel, however, as mentioned above, because all page table management functions and control register management functions have been hooked by HyperPS, the compromised HostOS kernel cannot subvert the HyperPS Space by using unverified page tables. 
Lastly, we clear interrupt with \verb|CLI| instruction again before we execute any instruction in the HyperPS Space. 
% divert execution into HyperPS Space.
The Exit Gate is the only interface that can divert execution back to Normal Space. It can only be invoked by HyperPS from the HyperPS Space. 
On receiving the invocation to Exit Gate, 
HyperPS will load the dedicated HostOS kernel page table into register CR3, recover interrupts and the saved kernel state. 
The Shared Buffer contains data and code shared by the Normal Space and the HyperPS Space. For example, as mentioned above, the entrance address of HyperPS Space and the return address to the Normal Space are stored in this buffer. HyperPS also stores the saved kernel state in this buffer. 
% In our prototype, we mapped the Switch Gate at the same place in both Normal Space and the HyperPS Space.

However, TLB becomes a subtle issue in the implementation of our Switch Gate. TLB is a special cache used to keep track of recently used PTE transactions.
Given a virtual address, the processor wll first examine the TLB if a PTE is present (TLB hit). If a match is found in the TLB, the processor retrieves the corresponding physical memory frame number from TLB directly. If the mapping is not cached by the TLB, the processor retrieves the physical memory page number from page table residing in the main memory and updates the new PTE into TLB. Thus, we need to flush TLB after we update both dedicated HostOS kernel page table and the page table used by HyperPS. 
In our prototype, we borrowed the idea in SecPod that clears the global bits in both the dedicated HostOS kernel page table and the HyperPS Space page table. By doing so, the TLB will always contain fresh address mappings after invoking the function \verb|flush_tlb_all()|.
% n HyperPS Space and

% there is one subtle issue in the implementation of the Switch Gate

% The switch gate is mapped at the same place in the Normal Space and the HyperPS Space, because the switch gate code must be called by the two worlds before and after switching. Of course, the entrance address must be protected after switching to HyperPS Space in case that a attacker accesses HyperPS Space causally after trusted boot. Protection to Switch Gate will be illustrated in the Section \ref{sec:securityforhyperps}.



% The shared buffer contains common data and code in Normal Space and the HyperPS Space. Common code is switch code, common data is entrance address to HyperPS Space and return address to the Normal World.
% On invoking Exit Gate,
% jump into
%  before
% address of page table

% HyperPS achieves the atomic secure switching
% Disabling interrupts
% 为什么要屏蔽中断，这里要说清除。

\iffalse
In the middle of Figure \ref{fig:address}, the switch gate includes entry/exit gate and shared buffer. Entry gate provides the only entrance to HyperPS Space and the exit gate provides the address for returning to the Normal Space. The shared buffer contains common data and code in Normal Space and the HyperPS Space. Common code is switch code, common data is entrance address to HyperPS Space and return address to the Normal World. The switch gate is mapped at the same place in the Normal Space and the HyperPS Space, because the switch gate code must be called by the two worlds before and after switching. Of course, the entrance address must be protected after switching to HyperPS Space in case that a attacker accesses HyperPS Space causally after trusted boot. Protection to Switch Gate will be illustrated in the Section \ref{sec:securityforhyperps}.
%添加Section的引用
\fi

\iffalse
except for that of HyperMI World. This can prevent compromised hypervisor from breaking the integrity of HyperMI World. Programs running in normal world can not access data in HyperMI World. On the right of Figure \ref{fig2}, all address is mapped in HyperMI page table.

 We use two isolated address spaces based on two sets of page tables to achieve isolation of HyperMI World.
Figure \ref{fig2} describes the address space layout of two worlds through two sets of page table, the normal page table and HyperMI page table. On the left of Figure \ref{fig2}, the normal page table contains code and data of the normal world except for that of HyperMI World. This can prevent compromised hypervisor from breaking the integrity of HyperMI World. Programs running in normal world can not access data in HyperMI World. On the right of Figure \ref{fig2}, all address is mapped in HyperMI page table.
HyperMI code remains executable and HyperMI data remains writable. What's the most important, kernel code is forbid to execute when HyperMI World is active, so that it can not attack HyperMI World.

\textbf{Creating Switch Gate}
In the middle of Figure \ref{fig2}, the switch gate includes entry/exit gate and shared buffer. Entry gate provides the only entrance to HyperMI World and the exit gate provides the address for returning to the normal world. The shared buffer contains common data and code in normal world and HyperMI World. Common code is switch code, common data is entrance address to HyperMI World and return address to the normal world. The switch gate is mapped at the same place in the normal world and HyperMI World because the switch gate code must be called by the two worlds before and after switching. Of course, the entrance address must be protected after switching to HyperMI World in case that a attacker accesses HyperMI World causally after trusted boot. This is introduced in section \ref{SG}.
\fi





\iffalse
下面的这部分内容应该是保护的内容，涉及的是EPT和缺页中断的处理，不应该是地址空间创建这部分内容。
在QEMU-KVM架构下，一台虚拟机的memory space同时受宿主机的page table和EPT两套页表管理。
% 在non-root模式下，
对于宿主机而言，虚拟机就是一个qemu进程，这个与其他的普通进程没有区别，宿主机通过传统的页表管理qemu所需要的所有地址空间。hostOS负责实际分配给该虚拟机的所有物理页框。
当EPT enable的时候，
在root模式下，EPT负责将qemu进程的

在QEMU-KVM架构下，以HostOS 视角看，整个虚拟机即为一个QEMU进程，EPT用于管理已经分配给QMEU进程中的物理页。
Traditional page tables continue to be reponsible for FVA-GPA, while EPT is responsible for GPA-HPA.
\fi


\iffalse
###################
三个章节的内容
KVM 函数hook 
EPT处理流程
KSM是特别要处理的内容
###################
\fi

\subsection{Privilege Deprivation and Management}%
\label{sub:privilege_deprivation_and_management}


In HyperPS, the HostOS has been deprived of the privileges of managing EPTs. This gives HyperPS complete control over the guest VM's virtual-physical memory mapping and protection. In our prototype, we hook all KVM's VMX and EPT functions to redirect EPT management to our HyperPS Space.

% TODO 上面说要保护管理EPT，但是这里为什么要从VMCS入手，这里要说明
\subsubsection{VMCS Hook}%
\label{ssub:vmcs_hook}


Based on Intel manuals, VMCS can only be manipulated by several privileged instructions: \verb|VMPTRLD|, \verb|VMCLEAR| \verb|VMPTRLD|, \verb|VMREAD|, \verb|VMWRITE|, \verb|VMLAUNCH|, and so on.
In the QEMU-KVM architecture, the KVM provides a wrapper around these privileged instructions. The QEMU does not need to deal architecture specific details, it just needs to invoke the wrapper functions in KVM with proper parameters.
% the KVM is responsible for executing these privileged instructions. The KVM provides a wrapper around these privileged instructions. The QEMU does not need to deal architecture specific details, it just need to invoke KVM functions with proper parameters.
In Linux, all VMX operation functions are defined in the file \verb|vmx_ops.h|. 
For example, \verb|vmcs_writel()| wraps the privileged instruction \verb|VMWRITE|, it will update the specified field of a VMCS with a given value. 
% the value to a VMCS filed
\verb|__vmcs_readl()| is one of wrapper functions to the privileged instruction \verb|VMREAD|, this function reads a field from a VMCS and returns field value. 
% it into
In our prototype, we implement all VMX functions in Normal Space with hooks to HyperPS Space to provide all VMX services. 
In particular, we prevent the HostOS/Hypervisor from loading an unverified EPTP. 
HyperPS interposes the execution of \verb|vmcs_writel()|, and the Context Management in the HyperPS Space Management component checks the invoked parameters and verifies if the write to \verb|VM-Execution Control Fields.EPTP| is legal or not. 
HyperPS also forbids arbitrary write to the \verb|VM-Function Controls| field in \verb|VM-Execution Control Fields|.
The field \verb|VM-Function Controls| contains the physical address of the 4-KByte EPTP list. Invalid value in the EPTP list may lead to an unverified EPTP value. 

\subsubsection{EPT Hook}%
\label{ssub:ept_hook}


In this paper, because EPTs have been removed from the Normal Space, 
HyperPS needs to hooks EPT functions that access EPTP and EPT Paging Structures to HyperPS Space, and implement these services in the HyperPS Space.
In QEMU-KVM architecture, the KVM is the component that maintains EPTs, while QEMU is responsible for requesting memory allocation.
Thus, in our prototype, we dig into KVM to find out all functions that process EPTPs and EPTs directly. Figure \ref{fig:impept} depicts how HyperPS handles all EPT management functions. 

\begin{figure}[htpb]
    \centering
    \includegraphics[width=1\linewidth]{./IMG/imp-ept-handle.pdf}
    \caption{HyperPS EPT Procedure}%
    \label{fig:impept}
\end{figure}

% MMU Initialization:
\textbf{EPT Creation}: The KVM will create and initialize MMU along with the creation of vcpu. 
If the EPT is supported and enabled by the hardware, The KVM module will invoke the function \verb|init_kvm_tdp_mmu| to initialize the MMU. 
Actually, the function \verb|init_kvm_tdp_mmu()| is just responsible for registering all kinds of EPT management functions to the inputted vcpu management structure: \verb|vcpu->arch.mmu|. 
For example, the EPT page fault function is initialized to \verb|kvm_tdp_page_fault()|, meanwhile inject page fault function is initialized to \verb|kvm_inject_page_fault()|. 
In our prototype, we hooked all these registered functions into HyperPS Space. However, it is far from sufficient to hook these functions only. We need to dig into the internal of these functions to find out all surplus functions that access VMCS or EPT directly.

Besides, in this paper, we implement a new structure VM-Mark Table to guarantee the legitimate relationship between the VM and the EPT. 
During the creation of EPT, the function \verb|vmx_load_mmu_pgd()| is responsible for writing the newly created EPTP to the corresponding VMCS.
In our prototype, as shown in Figure \ref{fig:impept}, we hooked this function into the HyperPS Space. In the HyperPS Space, we also implemented our protection that stores and synchronizes the corresponding EPTP value and VM identifier to VM-Mark Table. 


% we also hooked the function \verb|vmx_load_mmu_pgd()|, which will write the new created EPTP to the corresponding VMCS.
% In our prototype, as shown in Figure \ref{fig:impept}, we will store and synchronize the corresponding EPTP value and VM identifier to VM-Mark Table.
% guarantee that only legitimate EPTP can be loaded
% Actually, the \verb|init_kvm_tdp_mmu()| just registers lots of exception handling functions, such as \verb|kvm_tdp_page_fault()| to a stucture \verb|vcpu->arch.mmu|.
% If the EPT is supported, the function \verb|init_kvm_tdp_mmu| is responsible for initializing the MMU.
\iffalse
Runtime EPT Management: 
As shown in Figure \ref{fig:impept}, we classified all EPT management operations into five types: Page Fault, Update, Traverse, Load and Free. 
In our prototype, because EPT and EPTP have been removed from the Normal Space, we have to hook all these functions into the HyperPS Space and implement  the respective EPT access services in the HyperPS Space. 
\fi

% EPT Construction Process:
\textbf{EPT Page fault}:
The KVM adopts a similar page table construction process to the kernel page table that fills EPT paging structures by handling EPT page fault. 
As mentioned above, if the EPT page fault occurs, the KVM invokes the function \verb|kvm_tdp_page_fault()| to handle this exception. 
% As mentioned above, the KVM invokes the function \verb|kvm_tdp_page_fault()| to handle EPT page fault.
Typically, the KVM is not responsible for the allocation of physical pages. 
It is responsible for synchronizing the allocated physical page frame number (PFN) to the corresponding EPT Paging-structure. We classify EPT operations in EPT Page Fault into Update. 
% What KVM does is to synchronize the allocated physical page frame number (PFN) to the corresponding EPT paging-structure. We classify EPT operations in EPT Page Fault into Update.
In a virtualization environment, there is a memory reclamation technique, called Ballooning, that is used by the hypervisor to allow the physical host system to retrieve memories from certain guest virtual machine and share them with others. 
However, Ballooning may be abused to facilitate side channel attacks. 
In this paper, we take such kind of situation into consideration. As depicted in Figure ref{fig:impept}, 
HyperPS will format the allocated physical memory frame before mapping it in the EPT while executing the function \verb|kvm_tdp_page_fault()|. More details are illustrated in Section \ref{sub:ksm_handle}. 
% TODO 添加章节的引用
% we hook the function \verb|kvm_tdp_page_fault()| into HyperPS Space, and format the allocated physical memory frame before mapping it in the EPT in this function.
% HyperPS will formate the
% different virtual machines shared the same physical memory.

\textbf{EPT Traverse}: 
% Though HyperPS does not interpose the traversal of EPT,
Because all EPTs have been moved from the Normal Space to the HyperPS Space, though HyperPS does not interpose the traversal of EPT, HyperPS also needs to instrument EPT traversal functions, so that they can access EPTs. 
However, we do not need to re-implement EPT traversal services in the HyperPS Space. In our prototype, we just implement a hook function that will invoke the Switch Gate to retrieve the corresponding EPTP value or EPT Paging Structure value. 
For example, the function \verb|shadow_walk_init()| is responsible for initializing the struct \verb|kvm_shadow_walk_iterator| structure which will record the value of EPTP and be used in the traversal of EPTs. We added the hook function inside the function \verb|shadow_walk_init()| to access EPT in HyperPS Space. 

\textbf{EPT Load}: 
In this paper, we propose a VM-Mark table to tag the mapping relations between the EPT and the corresponding virtual machine. 
HyperPS will be engaged to check whether the loaded EPT corresponds to the virtual machine every time the virtual is going to executing VM-Entry. 
\verb|vcpu_enter_guest()| is an arch-specific function in KVM to start up a virtual machine. 
As depicted in Figure \ref{fig:impept}, we placed a hook before executing the function \verb|vmx_load_mmu_pgd()| inside this function. The function \verb|vmx_load_mmu_pgd()| is the final function that load the EPT. 
If the EPTP (the base address of the EPT) matches an item in the VM-Mark Table, HyperPS will allow the subsequent operations, such as EPTP Switch and EPT Load. Otherwise, HyperPS will terminate the execution of the corresponding virtual machine. 

\textbf{EPT Update}: 
In this paper, we propose a new structure: Page-Mark Table to record the relationships between EPT Paging-structures and the physical memory page frames. 
HyperPS guarantees that physical page frames with write permission can only be accessed with one determinate VM. 
Physical page frames shared by different machines can only be read-only. 
Besides, HyperPS guarantees that virtual machines participating the memory sharing are authenticated and recorded by us. 
Figure \ref{fig:impept} depicts the rough process of how HyperPS handles EPT Update. 
As mentioned above, in this paper, in addition to changing the permissions of EPT entries, HyperPS also regards the allocation of a new EPT Paging-structure as EPT Update. 
In our prototype, we do not get involved in new physical memory page frame allocation. We focus on operations to EPTs only. 
The function \verb|__direct_map()| in KVM is the core function to build new EPT entries. HyperPS places hooks inside this function to perfrom security checks. If the allocated physical frame number is untracked in the Page-Mark Table, HyperPS will first invokes the function mentioned above to format this allocated physical page. Then, HyperPS hooks the function \verb|kvm_mmu_get_page()|, the function \verb|link_shadow_page()|, and the function \verb|mmu_set_spte()| into the HyperPS Space.
In the HyperPS Space, HyperPS will initialize a new EPT Paging-structure, and link it to the EPT.
% and link it to the corresponding

\iffalse
access to one VM or shared with
the effective isolation between diffe
In this paper, we define EPT Update as assigning a new EPT paging-structure or updating EPT paging-structures. 
\verb|__direct_map()| is the core function to build the page table.
\verb|kvm_mmu_get_page()| 分配一个EPT 页表项 
\verb|link_shadow_page()| 将新分配到下一级页表页的基地址填充到当前页表项SPTE中

\verb|mmu_set_spte| is the final calling function to set the page table structure. 
\fi

\iffalse
if the the EPT and the 
every time a virtual machine is going to be loaded into Non-Root model. 
\verb|vcpu_enter_guest()| is an arch-specific function in KVM to start up a virtual machine. 
In this function, we placed a hook before executing the function \verb|vmx_load_mmu_pgd()| inside this function. 
This function will will invoke the function \verb|vmx_load_mmu_pgd()| to load the EPT. 
The KVM will invoke the function \verb|vcpu_enter_guest()| to 
to load the corresponding EPT 
Every time the virtual machine runs, execute \verb|vcpu_enter_guest()|, this function load EPT.
EPT traversal functions in HyperPS Space.
In our prototype, we do not re-implement all EPT traversal functions in HyperPS Space, but just implement a hook function to retrieve
to hook these EPT traversal functions. 
In our prototype, we 
The stucture \verb|kvm_shadow_walk_iterator| is the most important structure used in the traversal of the EPT. 
This structure recordes the value of EPTP. 
% In our prototype,


When Guest Address has EPT Violation, KVM uses \verb|kvm_shadow_walk_iterator| to complete the traversal of the EPT, look up the page table entry EPT corresponding to Guest Address step by step, and finally index to the corresponding page table entry in the leaf page table to get the Guest Address corresponding the number of the page frame.
The function \verb|shadow_walk_init()| takes the physical address of the guest where the EPT Violation occurred and the VCPU with EPT Violation as input. 
This function is responsible for initializing the struct \verb|kvm_shadow_walk_iterator| structure, preparing to traverse the EPT page table.

In this paper, HyperPS does not hook EPT traversal functions, such as data structure \verb|kvm_shadow_walk_iterator()| in KVM. 
\verb|kvm_walk_init_using_root()| takes \verb|kvm_shadow_walk_iterator| as input. 
\verb|shadow_walk_okay()| \verb|shadow_walk_next()|

\verb|kvm_shadow_walk_iterator| records the value of EPTP
\fi
% It just maintains EPTs. Thus,
% what the KVM does in Page Fault Handling is similar to
% As shown in Figure \ref{fig:impept}, we interfere in the EPT
% The EPT paging structures are also completed by handing page fault exceptions.
% the KVM is not responsible for the allocation of physical pages. It just maintains EPTs.
% Memory allocation are completed with QEMU and the HostOS Kernel.
% after the QEMU requested allocation
\iffalse
\verb|__direct_map()| is the core function to build the page table.
\verb|kvm_mmu_get_page()| 分配一个EPT 页表项 
\verb|link_shadow_page()| 将新分配到下一级页表页的基地址填充到当前页表项SPTE中

\verb|mmu_set_spte| is the final calling function to set the page table structure. 

HyperPS needs to hooks all EPT management function in the Normal Space to HyperPS Space. 
EPT Creation: 
% we hooked all EPT management operation functions.

If the EPT is supported, the function \verb|init_kvm_tdp_mmu| is responsible for initalizing the MMU. 

Though HyperPS does not interpose the traversal of EPT, Because all EPTs have been moved from the Normal Space to the HyperPS Space, HyperPS also need to hook these EPT traversal functions. 

When Guest Address has EPT Violation, KVM uses \verb|kvm_shadow_walk_iterator| to complete the traversal of the EPT, look up the page table entry EPT corresponding to Guest Address step by step, and finally index to the corresponding page table entry in the leaf page table to get the Guest Address corresponding the number of the page frame.
The function \verb|shadow_walk_init()| takes the physical address of the guest where the EPT Violation occurred and the VCPU with EPT Violation as input. 
This function is responsible for initializing the struct \verb|kvm_shadow_walk_iterator| structure, preparing to traverse the EPT page table.

In this paper, HyperPS does not hook EPT traversal functions, such as data structure \verb|kvm_shadow_walk_iterator()| in KVM. 
\verb|kvm_walk_init_using_root()| takes \verb|kvm_shadow_walk_iterator| as input. 
\verb|shadow_walk_okay()| \verb|shadow_walk_next()|

\verb|kvm_shadow_walk_iterator| records the value of EPTP

every time the virtual machine runs, execute \verb|vcpu_enter_guest()|, this function load EPT.

transfer \verb|kvm_mmu_load()| set customer CR3

KVM is not responsible for the allocation of physical pages, but maintains EPT. 

\verb|hva_to_pfn()|: get the host physical page frame number from the host vurtual address.

\verb|__direct_map()| is the core function to build the page table.
\verb|kvm_mmu_get_page()| 分配一个EPT 页表项 
\verb|link_shadow_page()| 将新分配到下一级页表页的基地址填充到当前页表项SPTE中

\verb|mmu_set_spte| is the final calling function to set the page table structure. 

when the page is invalid, it will eventually call \verb|kvm_mmu_free_page()| recycling, here is mainly to see when it will be recycled
when EPT is loaded, \verb|mmu_load_direct_root()| \verb|make_mmu_page_available|.
\fi

% which will crash
% HyperPS instrumented this function to prevnet the adversary from using a unverified page table.
% the respective hooked functions
% HyperPS hooks these functions into the HyperPS Space. In the HyperPS Space, Context Management in the HyperPS Space Management component check the invoked parameters and verifies if the write to \verb|VM-Execution Control Fields.EPTP| is legal or not.
\iffalse

\subsection{KSM Handle}%{}. 
% TODO 添加章节的引用
% we hook the function \verb|kvm_tdp_page_fault()| into HyperPS Space, and format the allocated physical memory frame before mapping it in the EPT in this function.
% HyperPS will formate the
% different virtual machines shared the same physical memory.

\textbf{EPT Traverse}: 
% Though HyperPS does not interpose the traversal of EPT,
Because all EPTs have been moved from the Normal Space to the HyperPS Space, though HyperPS does not interpose the traversal of EPT, HyperPS also need to instrument EPT traversal functions, so that they can access EPTs. 
However, we do not need to re-implement EPT traversal services in the HyperPS Space. In our prototype, we just implement a hook function that will invokes the Switch Gate to retrieve the corresponding EPTP value or EPT Paging Structure value. 
For example, the function \verb|shadow_walk_init()| is responsible for initializing the struct \verb|kvm_shadow_walk_iterator| structure which will record the value of EPTP and be used in the traversal of EPTs. We added the hook functions inside the function \verb|shadow_walk_init()| to access EPT in HyperPS Space. 

\textbf{EPT Load}: 
In this paper, we propose a VM-Mark table to tag the mapping relations between the EPT and the corresponding virtual machine. 
HyperPS will be engaged to check whether the loaded EPT corresponds to the virtual machine at every time the virtual is going to executing VM-Entry. 
\verb|vcpu_enter_guest()| is an arch-specific function in KVM to start up a virtual machine. 
As depected in Figure \ref{fig:impept}, we placed a hook before executing the function \verb|vmx_load_mmu_pgd()| inside this function. The function \verb|vmx_load_mmu_pgd()| is the final function that load the EPT. 
If the EPTP (the base address of the EPT) matches an item in the VM-Mark Table, HyperPS will allow the subsequent operations, such as EPTP Switch and EPT Load, otherwise HyperPS will terminate the execution of the corresponding virtual machine. 

\textbf{EPT Update}: 
In this paper, we propose a new structure: Page-Mark Table to record the relationships between EPT paging-structures and the physical memory page frames. 
HyperPS guarantees that physical page frame with write permission can only be accessed with one determinate VM. 
Physical page frames shared by different machines can only be read-only. 
Besides, HyperPS guarantees that virtual machines participating the memory sharing are authenticated and recorded by us. 
Figure \ref{fig:impept} depicts the rough process of how HyperPS handles EPT Update. 
As mentioned above, in this paper, in addition to changing the permissions of EPT entries, HyperPS also regards the allocation of a new EPT paging-structure as EPT Update. 
In our prototype, we do not get involved in new physical memory page frame allocation, we focus on operations to EPTs only. 
The function \verb|__direct_map()| in KVM is the core function to build new EPT entries. HyperPS places hooks inside this function to perfrom security checks. If the allocated physical frame number is untracked in the Page-Mark Table, HyperPS will first invokes the function mentioned above to format this allocated physical page. Then, HyperPS hooks the function \verb|kvm_mmu_get_page()|, the function \verb|link_shadow_page()|, and the function \verb|mmu_set_spte()| into the HyperPS Space.
In the HyperPS Space, HyperPS will initialize a new EPT paging-structure, and link it the EPT.
% and link it to the corresponding
\fi

\iffalse
access to one VM or shared with
the effective isolation between diffe
In this paper, we define EPT Update as assigning a new EPT paging-structure or updating EPT paging-structures. 
\verb|__direct_map()| is the core function to build the page table.
\verb|kvm_mmu_get_page()| 分配一个EPT 页表项 
\verb|link_shadow_page()| 将新分配到下一级页表页的基地址填充到当前页表项SPTE中

\verb|mmu_set_spte| is the final calling function to set the page table structure. 
\fi

\iffalse
if the the EPT and the 
every time a virtual machine is going to be loaded into Non-Root model. 
\verb|vcpu_enter_guest()| is an arch-specific function in KVM to start up a virtual machine. 
In this function, we placed a hook before executing the function \verb|vmx_load_mmu_pgd()| inside this function. 
This function will will invoke the function \verb|vmx_load_mmu_pgd()| to load the EPT. 
The KVM will invoke the function \verb|vcpu_enter_guest()| to 
to load the corresponding EPT 
Every time the virtual machine runs, execute \verb|vcpu_enter_guest()|, this function load EPT.
EPT traversal functions in HyperPS Space.
In our prototype, we do not re-implement all EPT traversal functions in HyperPS Space, but just implement a hook function to retrieve
to hook these EPT traversal functions. 
In our prototype, we 
The stucture \verb|kvm_shadow_walk_iterator| is the most important structure used in the traversal of the EPT. 
This structure recordes the value of EPTP. 
% In our prototype,


When Guest Address has EPT Violation, KVM uses \verb|kvm_shadow_walk_iterator| to complete the traversal of the EPT, look up the page table entry EPT corresponding to Guest Address step by step, and finally index to the corresponding page table entry in the leaf page table to get the Guest Address corresponding the number of the page frame.
The function \verb|shadow_walk_init()| takes the physical address of the guest where the EPT Violation occurred and the VCPU with EPT Violation as input. 
This function is responsible for initializing the struct \verb|kvm_shadow_walk_iterator| structure, preparing to traverse the EPT page table.

In this paper, HyperPS does not hook EPT traversal functions, such as data structure \verb|kvm_shadow_walk_iterator()| in KVM. 
\verb|kvm_walk_init_using_root()| takes \verb|kvm_shadow_walk_iterator| as input. 
\verb|shadow_walk_okay()| \verb|shadow_walk_next()|

\verb|kvm_shadow_walk_iterator| records the value of EPTP
\fi
% It just maintains EPTs. Thus,
% what the KVM does in Page Fault Handling is similar to
% As shown in Figure \ref{fig:impept}, we interfere in the EPT
% The EPT paging structures are also completed by handing page fault exceptions.
% the KVM is not responsible for the allocation of physical pages. It just maintains EPTs.
% Memory allocation are completed with QEMU and the HostOS Kernel.
% after the QEMU requested allocation
\iffalse
\verb|__direct_map()| is the core function to build the page table.
\verb|kvm_mmu_get_page()| 分配一个EPT 页表项 
\verb|link_shadow_page()| 将新分配到下一级页表页的基地址填充到当前页表项SPTE中

\verb|mmu_set_spte| is the final calling function to set the page table structure. 

HyperPS needs to hooks all EPT management function in the Normal Space to HyperPS Space. 
EPT Creation: 
% we hooked all EPT management operation functions.

If the EPT is supported, the function \verb|init_kvm_tdp_mmu| is responsible for initalizing the MMU. 

Though HyperPS does not interpose the traversal of EPT, Because all EPTs have been moved from the Normal Space to the HyperPS Space, HyperPS also need to hook these EPT traversal functions. 

When Guest Address has EPT Violation, KVM uses \verb|kvm_shadow_walk_iterator| to complete the traversal of the EPT, look up the page table entry EPT corresponding to Guest Address step by step, and finally index to the corresponding page table entry in the leaf page table to get the Guest Address corresponding the number of the page frame.
The function \verb|shadow_walk_init()| takes the physical address of the guest where the EPT Violation occurred and the VCPU with EPT Violation as input. 
This function is responsible for initializing the struct \verb|kvm_shadow_walk_iterator| structure, preparing to traverse the EPT page table.

In this paper, HyperPS does not hook EPT traversal functions, such as data structure \verb|kvm_shadow_walk_iterator()| in KVM. 
\verb|kvm_walk_init_using_root()| takes \verb|kvm_shadow_walk_iterator| as input. 
\verb|shadow_walk_okay()| \verb|shadow_walk_next()|

\verb|kvm_shadow_walk_iterator| records the value of EPTP

every time the virtual machine runs, execute \verb|vcpu_enter_guest()|, this function load EPT.

transfer \verb|kvm_mmu_load()| set customer CR3

KVM is not responsible for the allocation of physical pages, but maintains EPT. 

\verb|hva_to_pfn()|: get the host physical page frame number from the host vurtual address.

\verb|__direct_map()| is the core function to build the page table.
\verb|kvm_mmu_get_page()| 分配一个EPT 页表项 
\verb|link_shadow_page()| 将新分配到下一级页表页的基地址填充到当前页表项SPTE中

\verb|mmu_set_spte| is the final calling function to set the page table structure. 

when the page is invalid, it will eventually call \verb|kvm_mmu_free_page()| recycling, here is mainly to see when it will be recycled
when EPT is loaded, \verb|mmu_load_direct_root()| \verb|make_mmu_page_available|.
\fi

% which will crash
% HyperPS instrumented this function to prevnet the adversary from using a unverified page table.
% the respective hooked functions
% HyperPS hooks these functions into the HyperPS Space. In the HyperPS Space, Context Management in the HyperPS Space Management component check the invoked parameters and verifies if the write to \verb|VM-Execution Control Fields.EPTP| is legal or not.


\subsection{KSM Handle}%
\label{sub:ksm_handle}
Kernel Same-page Merging (KSM), used by the KVM Hypervisor, allows KVM guests to share identical memory pages. 
KSM enables the KVM Hypervisor to examine two or more already running virtual machines and compare their memory. If any memory region or pages are identical, KSM reduces multiple identical memory pages to a single page. 
% This merged page is marked Copy-On-Write (COW). If the contents of the page is modified by a guest virtual machine, a new page is created for that guest.
The KSM adopts two red-black trees: the unstable tree and the stable tree, to implement its service.
The unstable tree holds pointers to pages that have been found to be unchanged for a period of time. 
The stable tree holds pointers to all the merged pages (KSM pages), sorted by their contents. All pages in the stable tree are write-protected. 
If the contents of the page is modified by a guest virtual machine, a new page is created for that guest.
Once a merged page has been recorded into the stable tree, the merged page pointer will never be removed from the stable tree until all users have either modified or unmapped it. 
At runtime, for each page scanned, the KSM proceeds to search a match first in the stable tree that only contains already shared pages. If a match is found in the stable tree, KSM will merge this scanned page with the KSM page found in the stable. 
If no match is found in the stable tree, KSM will then search the unstable tree. If a match is found in the unstable tree, the page is merged with the page in the unstable tree, and the resulting KSM merged page is added to the stable tree. 

In this paper, as mentioned in Section \ref{ssub:ept_paging_structure_protection}, we also take KSM into consideration. 
\verb|stable_tree_insert()|, \verb|stable_tree_append()| are the functions in KSM to add the merged page into stable tree. 
Firstly, As mentioned above, we placed hooks in these stable tree operation functions to trap execution to HyperPS Space. 
In our prototype, the Page-Mark Table is used to record all physical page frames used by the VM. If a page is merged by KSM, HyperPS fills the \verb|SharedID| with the corresponding VM identifier. 
Secondly, Merging page results in EPT update too. HyperPS needs to get involved in the page merging process too. 
\verb|try_to_merge_one_page()| and \verb|try_to_merge_two_page()| are the function in KSM to merge two pages into one. 
For EPTs have been moved to HyperPS Space and EPT management functions are hooked to HyperPS Space too, we also hook these functions to HyprePS Space to synchronize the memory mapping changes to EPT.

\iffalse
Page-Mark Table is 
HyperPS will record
We present the field \verb|SharedID| in the Page-Mark Structure to acclimatize HyperPS to KSM. 
for all merged page are recorded in the stable tree.
As mentioned above, all merged page are recorded in the stable tree,
In our prototype, HyperPS placed hooks into the
HyperPS pays
\fi

\iffalse 

实现了虚拟机的隔离主要通过保护和隔离EPT和虚拟机内存来完成，主要完成4部分，1）实现vm-mark表，将VM与EPT进行绑定确保各虚拟机只能访问自己的EPT。2）hyperps剥离了EPT相关的所有访问函数，保证ept表的安全访问。以防被恶意更改。3）页分配时实现page-mark表，来标注page唯一的属主vm，保证vm-ept-page的一致性。在页分配时验证页的属主，空页绑定页与vm，非空页验证属主，以免页被重新分配。4）页释放时清除页内容。如果原vm的内容页在释放时未被清除，当该页再次分配给其余虚拟机时，其上的内容可能被恶意虚拟机读取而泄露数据。

We propose ept isolation and vm isolation by preventing ept access and released vm page access , following the steps. 1) Guarantee the consistency of vm and ept. Making vm-ept mark table to ensure EPT isolation and one VM only access own corresponding EPT. 2) Strips ept access privilege. Strips all access functions related to EPT to ensure safe access and to ept and prevent malicious changes. 3) Page-mark table. The page-mark table is created marking the unique owner vm of the page during page allocation. So the consistency of vm-ept-page can ensure ept isolation and vm isolation, one vm can only access own ept and own pages. During page allocation, the owner of the page is verified, empty pages are bound to the vm directly, and the allocated page is discarded to prevent the page from being remapped. 4)Clear page content when released. If the content page of the original vm is not cleared after being released, after allocated to other virtual machines again, the content on the page may be read by a malicious virtual machine so that privacy data may be leaked.
 
It is important to ensure EPT isolation and one VM only access own corresponding EPT. To ensure one EPT for one VM, HyperPS creates the VM-Mark structure stored in HyperPS World as Table I described. It records VMID, EPTID, EPT Address and binds them together. VMID is created when the VM is created. EPTID and EPT Address is recorded as long as the EPT of current VM is created. This table is destroy once the VM is shutdown or destroyed.
 
Vm-ept mark table is hidden in hyperps world. all access functions for EPT address must be executed in hyperps world. When EPT is created, use the hash function to construct the ID number of the ept according to the ept address, bind it to the current VMID as a structure, the relationship between VM and EPT is established. Other access functions of EPT, such as reading and writing,updating will be executed  in hyperps wolrd for safety.
Stripping EPT's access capability can prevent attackers from tampering with EPT. When 
\fi




\iffalse
5.2内存所有权跟踪

   为了确保VMM和它的guest VM之间的内存隔离，CloudVisor保持了一个表来跟踪每个物理内存页的所有权。这个表中的值是这个页的所有者ID。每个VM在被引导时被分配了一个独一无二的ID。VMM的ID被固定为0。CloudVisor确保一个物理内存页只能在同一时间被分配给一个所有者。
   在系统启动过程中，所有的除了在CloudVisor中的页都被VMM拥有。当guest VM的EPT被第一次加载进处理器时，CloudVisor进入整个EPT来找到所有被映射的页。这些页被认为被分配给guest VM。CloudVisor改变这些页的所有者给guest VM，并且将它从VMM的EPT中取消映射，这样VMM就再也不够触及这些页了。当一个页从EPT中被取消映射时，页的所有者被设置成VMM，并且这个页在VMM的EPT中被重新映射。
   无论何时VMM更新guest EPT，在EPT中的一个页错误（在Intel词汇中的EPT violation）会发生。CloudVisor通过验证页的所有者来处理错误。当一个新的映射被建立时，CloudVisor确保要被映射的页属于VMM。CloudVisor将它从VMM的EPT中取消映射，并且改变页的所有者给guest VM。当一个已存在的页被取消映射时，CloudVisor加密这个页的内容，把它映射到VMM中的EPT，并且改变VMM的页所有者。CloudVisor不允许一个页被映射到相同的EPT中超过一次。为了重新映射一个页，VMM需要首先取消映射它，然后将它重新映射到新的位置

5.3合法内存存取
   CloudVisor提供的内存隔离机制确保guest VM的整个内存空间不能被VMM和management VM存取。然而，有几种情况，VMM和management VM应当被允许存取guest VM的一些内存。在这样的情况下，CloudVisor干预并且帮助这样的存取来确保只有最小化的非敏感数据被泄露。
   特权指令，比如IO指令和控制寄存器的存取会导致trap（如VM退出），这些trap会被VMM处理。在一些情况下，VMM在guest VM的内存中需要得到指令操作码来仿效它。在这样的trap中，CloudVisor取得特权操作码，并且将它提供给VMM。因为CloudVisor只允许获取被程序计数器指向的一个操作码，VMM就不能够欺骗CloudVisor来取得任意没有权利的操作码，也不能任意触发陷阱来得到操作码。
   在一次trap中，故障指令的程序计数器是一个虚拟地址，并且内存操作数也被表达成虚拟的地址。VMM需要去查询guest VM中的页表来将虚拟地址翻译成guest物理地址，然后要进一步使用EPT翻译成host物理地址。为了处理这个情况，CloudVisor短暂地允许VMM来间接地读取操作码和内存操作数对应的guest页表条目。当一个trap由特权指令的执行产生时，CloudVisor得到指令的程序计数器并且分析这个指令来获取内存操作数。CloudVisor查询guest VM中的页表来获取需要的页表条目，来翻译程序计数器和内存操作数。当VMM存取页表时，CloudVisor提供给它先前获取的页表条目。为了减少跟特权指令仿真相关联的开销，CloudVisor使用一个缓冲区来高速缓冲每个VCPU的特权指令的页表条目。
   仿效IO存取时，当VMM也需要得到guest IO的缓冲区内容。当VMM存取IO缓冲区时，一个EPT错误会发生，CloudVisor通过复制 给VMM的数据 来处理错误。确切地说，当VMM从或者向guest VM复制数据时，CloudVisor验证guest VM的缓冲区地址是一个已知的IO缓冲区，并且决定是否这个缓冲区被磁盘IO所用（部分6.1）。

\fi
















